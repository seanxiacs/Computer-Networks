### analysis_pcap_tcp.py

##### Imports
In this sample_pinger.py file, the os, sys, struct, time, select, socket, and binascii libraries were imported. The binascii library was actually not used from my understanding but it was given in the skeleton code so it was left there. The os library was included to get the process ID to set myID used by both sendOnePing and receiveOnePing in the doOnePing. The sys library was used to parse hte arguments to see what server the pinger should ping as well as used for sys.platform in order to determine what os/platform the code is being run on to make sure the checksum is being processed correctly. THe struct library was used in order to create structures in order to both send and parse the data to and from binary more effectively. The time library was used for time.sleep(1) to make sure that the pings should go out abut once every second and for time.time() in order to get the time either for calculations or to put data into the packet. The select library was used for select.select() in order to select a value from a list of tuples in receiveOnePing. The socket library was used multiple times such as socket.recvfrom(), socket.inet_ntoa(), socket.htons(), socket.sendto(), socket.getprotobyname(), socket.socket(), socket.AF_INET, socket.RA but the biggest purpose was to create a raw socket to ping the servers.

##### Usage
This program was written in python and tested on a Windows 10 machine using VSCode and the VSCode built in terminal function. Should any of the following instructions not work for you if tested on a different platform, please attempt to try this on one matching the one it was written and originally tested on. In order to run this program. you should run python .\sample_pinger.py host specifically for Windows terminal.

##### Functionality
This program consists of 5 methods (not including main) which include: ping(), doOnePing(), sendOnePing, receiveOnePing, and checksum(). The main method will call ping(). Then ping() will call doOnePing() approximately once every second. Then doOnePing is tasked with creating the raw socket, calling sendOnePing, and then receiveOnePing and these two methods will perform the tasks that the names suggests, with sendOnePing() sending the ping to the destination server and receiveOnePing() tasked with receiving the pong. Both sendOnePing() and receiveOnePing() use checksum for their own purpose. The receiveOnePing() function is tasked with timing out the specified timeout (1 second) has passed assuming "that either the ping packet or the pong packet was lost in the network (or that the server is down)." As specified by the Additional Notes, we receive the structure ICMP_ECHO_REPLY and fetch the checksum, sequence number, time to live (TTL) and other information such as the source IP address of the pong packet received in order to be printed. The sequence number and time to live (TTL) was fetched but not used because the output of the homework document does not specify to print it. The function receiveOnePing will also attempt to make sure that the pong packet is correct by checking things such as type, code, and ID. Things not specified that needed to be parsed for but were parsed for because it was needed was the send_time in the data, length of the packet, and source IP address so that it can be printed. The program will print out what IP address it is pinging, how many bytes it receives as pong, the rtt time in ms, and after stopping using Ctrl+C, some summary ping statistics such as the rtt min/avg/max found over the course of the program running. The rtt is calculated  by subtracting receive and send time (now in s) and converting to ms by multiplying by 1000, the min is minimum of all previous mins and current rtt, the max is maximum of all previous maxes and current rtt, the sum is sum of all previous rtt and current rtt, the count is the count of all the pongs received. These are all updated for each receiveOnePing iteration once the pong is received. If no pongs are received, the ping program at the progam termination will print 'It seems that the all of the either ping or pong packets were lost in the network (or that all the server is down)' to let the user know. I apologize that this is a jumbled mess but I do not want to lose points for not missing some part that needs to be explained. I hope I didn't miss anything that I needed to include. 

##### Testing the Pinger
In order to test the pinger, specifically for scenario C, I had to go through many university websites to see which websites didn't give a "Request timed out" message. I am guessing it is because most of these university websites server's may block some types of ICMP packets? I am just making a guess since the network is really complex. Anyways, I ended up testing Google DNS Servers 8.8.8.8 like showin in the example program output in the homework document, localhost 127.0.0.1, stonybrook.edu 129.49.22.66, and cs.stonybrook.edu 23.185.0.2 for scenarios A and B. The stonybrook.edu always resulted in a "Request timed out." which may be caused by a multitude of reasons. I assume it is because I am pinging from outside the campus wifi? I assume the server just does not accept our ICMP packets but the cs.stonybrook.edu server replied to us. For scenario C, for Europe I tested the University of Cambridge in Cambridge, England website cam.ac.uk 128.232.132.8, for South America I tested the Universidade Federal do Rio de Janeiro in Rio de Janeiro, Brazil website ufrj.br 146.164.84.216, for Africa I tested the Kwame Nkrumah University Science & Technology in Kumasi, Ghana website knust.edu.gh 129.122.16.228, for Asia I tested the Tel Aviv University in Tel Aviv, Israel website english.tau.ac.il 132.66.11.168, and lastly, for Australia I tested the University of Queensland in Queensland, Australia website uq.edu.au 130.102.184.3. I tried to look for university websites that had rtts that did not have really low rtts which may seem to indicate that they were served from closeby in order to find the most plausible rtt values. These don't show how many different university websites that did not seem to work. The rtt is calculated by doing rtt = (timeReceived - timeSent) * 1000 and timeReceived is the time from time.time() when receiveOnePing gets the pong and the timeSent is parsed from the recPacket by "struct.unpack('d', recPacket[28:])" because in sendOnePing we put the time we send the packet out in the data.

##### D. Explain the differences in minimum round trip time to each of these servers in parts A, B, and C. 
--- 8.8.8.8 ping statistics ---
round-trip min/avg/max 14.817/21.875/29.898 ms
--- 127.0.0.1 ping statistics ---
round-trip min/avg/max 0.000/0.000/0.000 ms
--- stonybrook.edu ping statistics ---
It seems that the all of the either ping or pong packets were lost in the network (or that all the server is down)
--- cs.stonybrook.edu ping statistics ---
round-trip min/avg/max 14.123/18.510/24.281 ms
--- cam.ac.uk ping statistics ---
round-trip min/avg/max 95.881/101.574/121.129 ms
--- ufrj.br ping statistics ---
round-trip min/avg/max 142.438/157.131/191.663 ms
--- knust.edu.gh ping statistics ---
round-trip min/avg/max 204.724/209.408/220.206 ms
--- english.tau.ac.il ping statistics ---
round-trip min/avg/max 177.861/192.248/254.645 ms
--- uq.edu.au ping statistics ---
round-trip min/avg/max 294.179/311.535/357.333 ms
As expected, the further away the likely location of the server is from New York (location where this program is being tested from), then the higher the general trend of the minimum rtt to these servers is. In general, from what I remember, Australia is the furthest followed by Ghana, Israel, Brazil, England, and then the US, so these website minimum rtt follows the higher distance means higher minimum rtt trend. I don't want to search up the distance from New York to the respective cities of each university website I used but I believe they likely correspond to distance between New York and the University City. This is likely because the time it takes for packets to travel across the network increases the further away the server is from the client. 